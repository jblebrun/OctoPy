import unittest
import os

from octopy.parser import Parser
from octopy.tokenizer import tokenize

curdir = os.path.dirname(__file__) 
def filehere(name): return os.path.join(curdir, name)

class MetaTest(type):
    """
    This metaclass looks through the /testdata directory for any .8o files, and for each one it finds,
    adds a test function to the TestPrograms class.
    """

    def testrunner(cls, name):
        def tf(self): 
            self.run_program_test(name)
        return tf

    def __new__(cls, name, bases, dct):
        x = super().__new__(cls, name, bases, dct)
        testsrcs = [f for f in os.listdir(filehere("testdata")) if f.endswith(".8o")]
        for src in testsrcs:
            name = os.path.join("testdata", src.split(".")[0])
            print("DISCOVERED TEST ", name)
            tf = cls.testrunner(cls, name)
            setattr(x, "test_{}".format(name), tf)
        return x

class TestPrograms(unittest.TestCase, metaclass=MetaTest):
    """ 
    The actual tests in this class are generated by the MetaTest metaclass
    """

    def run_program_test(self, name):
        """
        Generate a program with OctoPy, and compare the results to a provided
        output binary for comparison.

        Mismatches will throw an error, and include the instructions that differ
        """

        print("Running test for", name)
        # Compile the program
        srcfile = filehere("{}.8o".format(name))
        with open(srcfile) as src:
            p = Parser(tokenize(src))
            p.parse()
            p.resolve()

        # Generate the comparisons for each 16 byte group
        pc = 0
        diffs = []
        expectfile = os.path.join(curdir, "{}.expect.ch8".format(name))
        expectsize = os.path.getsize(expectfile)
        with open(expectfile) as expect:
            upto = max(expectsize, len(p.program))
            while pc < upto:
                nextexpect = expect.buffer.read(16)
                diffs += self.compareProgramLines(pc, p.program[pc:], nextexpect)
                pc += 16
        
        ## Emit results if needed
        if len(diffs) > 0:
            self.fail("Mismatched Output\n" + "".join(diffs))


    def compareProgramLines(self, pc, src, expect):
        """
        Check a row of up to 16 bytes. If there are any mismatches, generate
        a differences line. 
        """
        srcwords = [self.word(src[i:]) for i in range(0, 8)]
        expectwords = [self.word(expect[i:]) for i in range(0, 8)]

        diffs = [" " if si == ei else "*" for si, ei in zip(srcwords, expectwords)]

        diffCount = len([d for d in diffs if d == "*"])

        if diffCount > 0:
            return """
    -{:04X}: {}
    +{:04X}: {}
            """.format(
                pc, self.diffLine(srcwords, diffs),
                pc, self.diffLine(expectwords, diffs)
            )

        return ""

    def diffLine(self, line, diffs):
        items = ["{}{}".format(diff,item) for diff,item in zip(diffs, line)]
        return " ".join(items)


    def word(self, data):
        """ Create a word for the output lines. """
        byte1 = "" if len(data) < 1 else "{:02X}".format(data[0])
        byte2 = "" if len(data) < 2 else "{:02X}".format(data[1])
        return byte1+byte2

if __name__ == '__main__': unittest.main()
